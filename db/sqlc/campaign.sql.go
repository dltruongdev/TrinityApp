// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: campaign.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createCampaign = `-- name: CreateCampaign :one
INSERT INTO Campaigns (name, description, code, start_date, end_date, max_vouchers, voucher_lifetime, discount_percentage)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING campaign_id, name, description, code, start_date, end_date, max_vouchers, redeemed_vouchers, voucher_lifetime, discount_percentage, created_at, updated_at
`

type CreateCampaignParams struct {
	Name               string         `json:"name"`
	Description        sql.NullString `json:"description"`
	Code               string         `json:"code"`
	StartDate          time.Time      `json:"start_date"`
	EndDate            time.Time      `json:"end_date"`
	MaxVouchers        int32          `json:"max_vouchers"`
	VoucherLifetime    int32          `json:"voucher_lifetime"`
	DiscountPercentage int32          `json:"discount_percentage"`
}

func (q *Queries) CreateCampaign(ctx context.Context, arg CreateCampaignParams) (Campaign, error) {
	row := q.db.QueryRowContext(ctx, createCampaign,
		arg.Name,
		arg.Description,
		arg.Code,
		arg.StartDate,
		arg.EndDate,
		arg.MaxVouchers,
		arg.VoucherLifetime,
		arg.DiscountPercentage,
	)
	var i Campaign
	err := row.Scan(
		&i.CampaignID,
		&i.Name,
		&i.Description,
		&i.Code,
		&i.StartDate,
		&i.EndDate,
		&i.MaxVouchers,
		&i.RedeemedVouchers,
		&i.VoucherLifetime,
		&i.DiscountPercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCampaignForUpdate = `-- name: GetCampaignForUpdate :one
SELECT 
    name, 
    code,
    end_date, 
    max_vouchers, 
    voucher_lifetime, 
    discount_percentage,
    start_date <= NOW() AND end_date > NOW() AND redeemed_vouchers < max_vouchers AS isValid
FROM 
    Campaigns
WHERE 
    code = $1
FOR NO KEY UPDATE
`

type GetCampaignForUpdateRow struct {
	Name               string       `json:"name"`
	Code               string       `json:"code"`
	EndDate            time.Time    `json:"end_date"`
	MaxVouchers        int32        `json:"max_vouchers"`
	VoucherLifetime    int32        `json:"voucher_lifetime"`
	DiscountPercentage int32        `json:"discount_percentage"`
	Isvalid            sql.NullBool `json:"isvalid"`
}

func (q *Queries) GetCampaignForUpdate(ctx context.Context, code string) (GetCampaignForUpdateRow, error) {
	row := q.db.QueryRowContext(ctx, getCampaignForUpdate, code)
	var i GetCampaignForUpdateRow
	err := row.Scan(
		&i.Name,
		&i.Code,
		&i.EndDate,
		&i.MaxVouchers,
		&i.VoucherLifetime,
		&i.DiscountPercentage,
		&i.Isvalid,
	)
	return i, err
}

const increaseRedeemedVoucher = `-- name: IncreaseRedeemedVoucher :one
UPDATE Campaigns
SET redeemed_vouchers = redeemed_vouchers + 1
WHERE code = $1
AND end_date > NOW()
AND redeemed_vouchers < max_vouchers
RETURNING 
    start_date, 
    end_date, 
    voucher_lifetime, 
    discount_percentage
`

type IncreaseRedeemedVoucherRow struct {
	StartDate          time.Time `json:"start_date"`
	EndDate            time.Time `json:"end_date"`
	VoucherLifetime    int32     `json:"voucher_lifetime"`
	DiscountPercentage int32     `json:"discount_percentage"`
}

// - Doing update directly will lock the record for update, if concurrent update happens (when two user finish register at the same time and there only one voucher left to be generated) this will keep the logic correctly
func (q *Queries) IncreaseRedeemedVoucher(ctx context.Context, code string) (IncreaseRedeemedVoucherRow, error) {
	row := q.db.QueryRowContext(ctx, increaseRedeemedVoucher, code)
	var i IncreaseRedeemedVoucherRow
	err := row.Scan(
		&i.StartDate,
		&i.EndDate,
		&i.VoucherLifetime,
		&i.DiscountPercentage,
	)
	return i, err
}

const isCampaignValid = `-- name: IsCampaignValid :one
SELECT EXISTS (
            SELECT 1 
            FROM Campaigns 
            WHERE code = $1 AND end_date > $2 AND start_date < $2) isValid
`

type IsCampaignValidParams struct {
	Code    string    `json:"code"`
	EndDate time.Time `json:"end_date"`
}

func (q *Queries) IsCampaignValid(ctx context.Context, arg IsCampaignValidParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isCampaignValid, arg.Code, arg.EndDate)
	var isvalid bool
	err := row.Scan(&isvalid)
	return isvalid, err
}
